// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	account "github.com/Orendev/gokeeper/internal/pkg/domain/account"

	binary "github.com/Orendev/gokeeper/internal/pkg/domain/binary"

	card "github.com/Orendev/gokeeper/internal/pkg/domain/card"

	context "context"

	email "github.com/Orendev/gokeeper/pkg/type/email"

	mock "github.com/stretchr/testify/mock"

	password "github.com/Orendev/gokeeper/pkg/type/password"

	queryParameter "github.com/Orendev/gokeeper/pkg/type/queryParameter"

	text "github.com/Orendev/gokeeper/internal/pkg/domain/text"

	user "github.com/Orendev/gokeeper/internal/pkg/domain/user"

	uuid "github.com/google/uuid"
)

// Storage is an autogenerated mock type for the Storage type
type Storage struct {
	mock.Mock
}

type Storage_Expecter struct {
	mock *mock.Mock
}

func (_m *Storage) EXPECT() *Storage_Expecter {
	return &Storage_Expecter{mock: &_m.Mock}
}

// CountAccount provides a mock function with given fields: ctx, parameter
func (_m *Storage) CountAccount(ctx context.Context, parameter queryParameter.QueryParameter) (uint64, error) {
	ret := _m.Called(ctx, parameter)

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) (uint64, error)); ok {
		return rf(ctx, parameter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) uint64); ok {
		r0 = rf(ctx, parameter)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, queryParameter.QueryParameter) error); ok {
		r1 = rf(ctx, parameter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_CountAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountAccount'
type Storage_CountAccount_Call struct {
	*mock.Call
}

// CountAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - parameter queryParameter.QueryParameter
func (_e *Storage_Expecter) CountAccount(ctx interface{}, parameter interface{}) *Storage_CountAccount_Call {
	return &Storage_CountAccount_Call{Call: _e.mock.On("CountAccount", ctx, parameter)}
}

func (_c *Storage_CountAccount_Call) Run(run func(ctx context.Context, parameter queryParameter.QueryParameter)) *Storage_CountAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(queryParameter.QueryParameter))
	})
	return _c
}

func (_c *Storage_CountAccount_Call) Return(_a0 uint64, _a1 error) *Storage_CountAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_CountAccount_Call) RunAndReturn(run func(context.Context, queryParameter.QueryParameter) (uint64, error)) *Storage_CountAccount_Call {
	_c.Call.Return(run)
	return _c
}

// CountBinary provides a mock function with given fields: ctx, parameter
func (_m *Storage) CountBinary(ctx context.Context, parameter queryParameter.QueryParameter) (uint64, error) {
	ret := _m.Called(ctx, parameter)

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) (uint64, error)); ok {
		return rf(ctx, parameter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) uint64); ok {
		r0 = rf(ctx, parameter)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, queryParameter.QueryParameter) error); ok {
		r1 = rf(ctx, parameter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_CountBinary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountBinary'
type Storage_CountBinary_Call struct {
	*mock.Call
}

// CountBinary is a helper method to define mock.On call
//   - ctx context.Context
//   - parameter queryParameter.QueryParameter
func (_e *Storage_Expecter) CountBinary(ctx interface{}, parameter interface{}) *Storage_CountBinary_Call {
	return &Storage_CountBinary_Call{Call: _e.mock.On("CountBinary", ctx, parameter)}
}

func (_c *Storage_CountBinary_Call) Run(run func(ctx context.Context, parameter queryParameter.QueryParameter)) *Storage_CountBinary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(queryParameter.QueryParameter))
	})
	return _c
}

func (_c *Storage_CountBinary_Call) Return(_a0 uint64, _a1 error) *Storage_CountBinary_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_CountBinary_Call) RunAndReturn(run func(context.Context, queryParameter.QueryParameter) (uint64, error)) *Storage_CountBinary_Call {
	_c.Call.Return(run)
	return _c
}

// CountCard provides a mock function with given fields: ctx, parameter
func (_m *Storage) CountCard(ctx context.Context, parameter queryParameter.QueryParameter) (uint64, error) {
	ret := _m.Called(ctx, parameter)

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) (uint64, error)); ok {
		return rf(ctx, parameter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) uint64); ok {
		r0 = rf(ctx, parameter)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, queryParameter.QueryParameter) error); ok {
		r1 = rf(ctx, parameter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_CountCard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountCard'
type Storage_CountCard_Call struct {
	*mock.Call
}

// CountCard is a helper method to define mock.On call
//   - ctx context.Context
//   - parameter queryParameter.QueryParameter
func (_e *Storage_Expecter) CountCard(ctx interface{}, parameter interface{}) *Storage_CountCard_Call {
	return &Storage_CountCard_Call{Call: _e.mock.On("CountCard", ctx, parameter)}
}

func (_c *Storage_CountCard_Call) Run(run func(ctx context.Context, parameter queryParameter.QueryParameter)) *Storage_CountCard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(queryParameter.QueryParameter))
	})
	return _c
}

func (_c *Storage_CountCard_Call) Return(_a0 uint64, _a1 error) *Storage_CountCard_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_CountCard_Call) RunAndReturn(run func(context.Context, queryParameter.QueryParameter) (uint64, error)) *Storage_CountCard_Call {
	_c.Call.Return(run)
	return _c
}

// CountText provides a mock function with given fields: ctx, parameter
func (_m *Storage) CountText(ctx context.Context, parameter queryParameter.QueryParameter) (uint64, error) {
	ret := _m.Called(ctx, parameter)

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) (uint64, error)); ok {
		return rf(ctx, parameter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) uint64); ok {
		r0 = rf(ctx, parameter)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, queryParameter.QueryParameter) error); ok {
		r1 = rf(ctx, parameter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_CountText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountText'
type Storage_CountText_Call struct {
	*mock.Call
}

// CountText is a helper method to define mock.On call
//   - ctx context.Context
//   - parameter queryParameter.QueryParameter
func (_e *Storage_Expecter) CountText(ctx interface{}, parameter interface{}) *Storage_CountText_Call {
	return &Storage_CountText_Call{Call: _e.mock.On("CountText", ctx, parameter)}
}

func (_c *Storage_CountText_Call) Run(run func(ctx context.Context, parameter queryParameter.QueryParameter)) *Storage_CountText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(queryParameter.QueryParameter))
	})
	return _c
}

func (_c *Storage_CountText_Call) Return(_a0 uint64, _a1 error) *Storage_CountText_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_CountText_Call) RunAndReturn(run func(context.Context, queryParameter.QueryParameter) (uint64, error)) *Storage_CountText_Call {
	_c.Call.Return(run)
	return _c
}

// CountUser provides a mock function with given fields: ctx, parameter
func (_m *Storage) CountUser(ctx context.Context, parameter queryParameter.QueryParameter) (uint64, error) {
	ret := _m.Called(ctx, parameter)

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) (uint64, error)); ok {
		return rf(ctx, parameter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) uint64); ok {
		r0 = rf(ctx, parameter)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, queryParameter.QueryParameter) error); ok {
		r1 = rf(ctx, parameter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_CountUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountUser'
type Storage_CountUser_Call struct {
	*mock.Call
}

// CountUser is a helper method to define mock.On call
//   - ctx context.Context
//   - parameter queryParameter.QueryParameter
func (_e *Storage_Expecter) CountUser(ctx interface{}, parameter interface{}) *Storage_CountUser_Call {
	return &Storage_CountUser_Call{Call: _e.mock.On("CountUser", ctx, parameter)}
}

func (_c *Storage_CountUser_Call) Run(run func(ctx context.Context, parameter queryParameter.QueryParameter)) *Storage_CountUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(queryParameter.QueryParameter))
	})
	return _c
}

func (_c *Storage_CountUser_Call) Return(_a0 uint64, _a1 error) *Storage_CountUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_CountUser_Call) RunAndReturn(run func(context.Context, queryParameter.QueryParameter) (uint64, error)) *Storage_CountUser_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAccount provides a mock function with given fields: ctx, _a1
func (_m *Storage) CreateAccount(ctx context.Context, _a1 *account.Account) (*account.Account, error) {
	ret := _m.Called(ctx, _a1)

	var r0 *account.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *account.Account) (*account.Account, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *account.Account) *account.Account); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *account.Account) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_CreateAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAccount'
type Storage_CreateAccount_Call struct {
	*mock.Call
}

// CreateAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *account.Account
func (_e *Storage_Expecter) CreateAccount(ctx interface{}, _a1 interface{}) *Storage_CreateAccount_Call {
	return &Storage_CreateAccount_Call{Call: _e.mock.On("CreateAccount", ctx, _a1)}
}

func (_c *Storage_CreateAccount_Call) Run(run func(ctx context.Context, _a1 *account.Account)) *Storage_CreateAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*account.Account))
	})
	return _c
}

func (_c *Storage_CreateAccount_Call) Return(_a0 *account.Account, _a1 error) *Storage_CreateAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_CreateAccount_Call) RunAndReturn(run func(context.Context, *account.Account) (*account.Account, error)) *Storage_CreateAccount_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBinary provides a mock function with given fields: ctx, _a1
func (_m *Storage) CreateBinary(ctx context.Context, _a1 *binary.BinaryData) (*binary.BinaryData, error) {
	ret := _m.Called(ctx, _a1)

	var r0 *binary.BinaryData
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *binary.BinaryData) (*binary.BinaryData, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *binary.BinaryData) *binary.BinaryData); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*binary.BinaryData)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *binary.BinaryData) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_CreateBinary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBinary'
type Storage_CreateBinary_Call struct {
	*mock.Call
}

// CreateBinary is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *binary.BinaryData
func (_e *Storage_Expecter) CreateBinary(ctx interface{}, _a1 interface{}) *Storage_CreateBinary_Call {
	return &Storage_CreateBinary_Call{Call: _e.mock.On("CreateBinary", ctx, _a1)}
}

func (_c *Storage_CreateBinary_Call) Run(run func(ctx context.Context, _a1 *binary.BinaryData)) *Storage_CreateBinary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*binary.BinaryData))
	})
	return _c
}

func (_c *Storage_CreateBinary_Call) Return(_a0 *binary.BinaryData, _a1 error) *Storage_CreateBinary_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_CreateBinary_Call) RunAndReturn(run func(context.Context, *binary.BinaryData) (*binary.BinaryData, error)) *Storage_CreateBinary_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCard provides a mock function with given fields: ctx, _a1
func (_m *Storage) CreateCard(ctx context.Context, _a1 *card.CardData) (*card.CardData, error) {
	ret := _m.Called(ctx, _a1)

	var r0 *card.CardData
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *card.CardData) (*card.CardData, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *card.CardData) *card.CardData); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*card.CardData)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *card.CardData) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_CreateCard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCard'
type Storage_CreateCard_Call struct {
	*mock.Call
}

// CreateCard is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *card.CardData
func (_e *Storage_Expecter) CreateCard(ctx interface{}, _a1 interface{}) *Storage_CreateCard_Call {
	return &Storage_CreateCard_Call{Call: _e.mock.On("CreateCard", ctx, _a1)}
}

func (_c *Storage_CreateCard_Call) Run(run func(ctx context.Context, _a1 *card.CardData)) *Storage_CreateCard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*card.CardData))
	})
	return _c
}

func (_c *Storage_CreateCard_Call) Return(_a0 *card.CardData, _a1 error) *Storage_CreateCard_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_CreateCard_Call) RunAndReturn(run func(context.Context, *card.CardData) (*card.CardData, error)) *Storage_CreateCard_Call {
	_c.Call.Return(run)
	return _c
}

// CreateText provides a mock function with given fields: ctx, _a1
func (_m *Storage) CreateText(ctx context.Context, _a1 *text.TextData) (*text.TextData, error) {
	ret := _m.Called(ctx, _a1)

	var r0 *text.TextData
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *text.TextData) (*text.TextData, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *text.TextData) *text.TextData); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*text.TextData)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *text.TextData) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_CreateText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateText'
type Storage_CreateText_Call struct {
	*mock.Call
}

// CreateText is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *text.TextData
func (_e *Storage_Expecter) CreateText(ctx interface{}, _a1 interface{}) *Storage_CreateText_Call {
	return &Storage_CreateText_Call{Call: _e.mock.On("CreateText", ctx, _a1)}
}

func (_c *Storage_CreateText_Call) Run(run func(ctx context.Context, _a1 *text.TextData)) *Storage_CreateText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*text.TextData))
	})
	return _c
}

func (_c *Storage_CreateText_Call) Return(_a0 *text.TextData, _a1 error) *Storage_CreateText_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_CreateText_Call) RunAndReturn(run func(context.Context, *text.TextData) (*text.TextData, error)) *Storage_CreateText_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function with given fields: ctx, _a1
func (_m *Storage) CreateUser(ctx context.Context, _a1 *user.User) (*user.User, error) {
	ret := _m.Called(ctx, _a1)

	var r0 *user.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.User) (*user.User, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.User) *user.User); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.User) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type Storage_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *user.User
func (_e *Storage_Expecter) CreateUser(ctx interface{}, _a1 interface{}) *Storage_CreateUser_Call {
	return &Storage_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, _a1)}
}

func (_c *Storage_CreateUser_Call) Run(run func(ctx context.Context, _a1 *user.User)) *Storage_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*user.User))
	})
	return _c
}

func (_c *Storage_CreateUser_Call) Return(_a0 *user.User, _a1 error) *Storage_CreateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_CreateUser_Call) RunAndReturn(run func(context.Context, *user.User) (*user.User, error)) *Storage_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAccount provides a mock function with given fields: ctx, id
func (_m *Storage) DeleteAccount(ctx context.Context, id uuid.UUID) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Storage_DeleteAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAccount'
type Storage_DeleteAccount_Call struct {
	*mock.Call
}

// DeleteAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *Storage_Expecter) DeleteAccount(ctx interface{}, id interface{}) *Storage_DeleteAccount_Call {
	return &Storage_DeleteAccount_Call{Call: _e.mock.On("DeleteAccount", ctx, id)}
}

func (_c *Storage_DeleteAccount_Call) Run(run func(ctx context.Context, id uuid.UUID)) *Storage_DeleteAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *Storage_DeleteAccount_Call) Return(_a0 error) *Storage_DeleteAccount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_DeleteAccount_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *Storage_DeleteAccount_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBinary provides a mock function with given fields: ctx, ID
func (_m *Storage) DeleteBinary(ctx context.Context, ID uuid.UUID) error {
	ret := _m.Called(ctx, ID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, ID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Storage_DeleteBinary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBinary'
type Storage_DeleteBinary_Call struct {
	*mock.Call
}

// DeleteBinary is a helper method to define mock.On call
//   - ctx context.Context
//   - ID uuid.UUID
func (_e *Storage_Expecter) DeleteBinary(ctx interface{}, ID interface{}) *Storage_DeleteBinary_Call {
	return &Storage_DeleteBinary_Call{Call: _e.mock.On("DeleteBinary", ctx, ID)}
}

func (_c *Storage_DeleteBinary_Call) Run(run func(ctx context.Context, ID uuid.UUID)) *Storage_DeleteBinary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *Storage_DeleteBinary_Call) Return(_a0 error) *Storage_DeleteBinary_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_DeleteBinary_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *Storage_DeleteBinary_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCard provides a mock function with given fields: ctx, ID
func (_m *Storage) DeleteCard(ctx context.Context, ID uuid.UUID) error {
	ret := _m.Called(ctx, ID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, ID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Storage_DeleteCard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCard'
type Storage_DeleteCard_Call struct {
	*mock.Call
}

// DeleteCard is a helper method to define mock.On call
//   - ctx context.Context
//   - ID uuid.UUID
func (_e *Storage_Expecter) DeleteCard(ctx interface{}, ID interface{}) *Storage_DeleteCard_Call {
	return &Storage_DeleteCard_Call{Call: _e.mock.On("DeleteCard", ctx, ID)}
}

func (_c *Storage_DeleteCard_Call) Run(run func(ctx context.Context, ID uuid.UUID)) *Storage_DeleteCard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *Storage_DeleteCard_Call) Return(_a0 error) *Storage_DeleteCard_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_DeleteCard_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *Storage_DeleteCard_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteText provides a mock function with given fields: ctx, ID
func (_m *Storage) DeleteText(ctx context.Context, ID uuid.UUID) error {
	ret := _m.Called(ctx, ID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, ID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Storage_DeleteText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteText'
type Storage_DeleteText_Call struct {
	*mock.Call
}

// DeleteText is a helper method to define mock.On call
//   - ctx context.Context
//   - ID uuid.UUID
func (_e *Storage_Expecter) DeleteText(ctx interface{}, ID interface{}) *Storage_DeleteText_Call {
	return &Storage_DeleteText_Call{Call: _e.mock.On("DeleteText", ctx, ID)}
}

func (_c *Storage_DeleteText_Call) Run(run func(ctx context.Context, ID uuid.UUID)) *Storage_DeleteText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *Storage_DeleteText_Call) Return(_a0 error) *Storage_DeleteText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_DeleteText_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *Storage_DeleteText_Call {
	_c.Call.Return(run)
	return _c
}

// ListAccount provides a mock function with given fields: ctx, parameter
func (_m *Storage) ListAccount(ctx context.Context, parameter queryParameter.QueryParameter) (*account.ListAccountViewModel, error) {
	ret := _m.Called(ctx, parameter)

	var r0 *account.ListAccountViewModel
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) (*account.ListAccountViewModel, error)); ok {
		return rf(ctx, parameter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) *account.ListAccountViewModel); ok {
		r0 = rf(ctx, parameter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.ListAccountViewModel)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, queryParameter.QueryParameter) error); ok {
		r1 = rf(ctx, parameter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_ListAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAccount'
type Storage_ListAccount_Call struct {
	*mock.Call
}

// ListAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - parameter queryParameter.QueryParameter
func (_e *Storage_Expecter) ListAccount(ctx interface{}, parameter interface{}) *Storage_ListAccount_Call {
	return &Storage_ListAccount_Call{Call: _e.mock.On("ListAccount", ctx, parameter)}
}

func (_c *Storage_ListAccount_Call) Run(run func(ctx context.Context, parameter queryParameter.QueryParameter)) *Storage_ListAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(queryParameter.QueryParameter))
	})
	return _c
}

func (_c *Storage_ListAccount_Call) Return(_a0 *account.ListAccountViewModel, _a1 error) *Storage_ListAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_ListAccount_Call) RunAndReturn(run func(context.Context, queryParameter.QueryParameter) (*account.ListAccountViewModel, error)) *Storage_ListAccount_Call {
	_c.Call.Return(run)
	return _c
}

// ListBinary provides a mock function with given fields: ctx, parameter
func (_m *Storage) ListBinary(ctx context.Context, parameter queryParameter.QueryParameter) (*binary.ListBinaryViewModel, error) {
	ret := _m.Called(ctx, parameter)

	var r0 *binary.ListBinaryViewModel
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) (*binary.ListBinaryViewModel, error)); ok {
		return rf(ctx, parameter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) *binary.ListBinaryViewModel); ok {
		r0 = rf(ctx, parameter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*binary.ListBinaryViewModel)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, queryParameter.QueryParameter) error); ok {
		r1 = rf(ctx, parameter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_ListBinary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBinary'
type Storage_ListBinary_Call struct {
	*mock.Call
}

// ListBinary is a helper method to define mock.On call
//   - ctx context.Context
//   - parameter queryParameter.QueryParameter
func (_e *Storage_Expecter) ListBinary(ctx interface{}, parameter interface{}) *Storage_ListBinary_Call {
	return &Storage_ListBinary_Call{Call: _e.mock.On("ListBinary", ctx, parameter)}
}

func (_c *Storage_ListBinary_Call) Run(run func(ctx context.Context, parameter queryParameter.QueryParameter)) *Storage_ListBinary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(queryParameter.QueryParameter))
	})
	return _c
}

func (_c *Storage_ListBinary_Call) Return(_a0 *binary.ListBinaryViewModel, _a1 error) *Storage_ListBinary_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_ListBinary_Call) RunAndReturn(run func(context.Context, queryParameter.QueryParameter) (*binary.ListBinaryViewModel, error)) *Storage_ListBinary_Call {
	_c.Call.Return(run)
	return _c
}

// ListCard provides a mock function with given fields: ctx, parameter
func (_m *Storage) ListCard(ctx context.Context, parameter queryParameter.QueryParameter) (*card.ListCardViewModel, error) {
	ret := _m.Called(ctx, parameter)

	var r0 *card.ListCardViewModel
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) (*card.ListCardViewModel, error)); ok {
		return rf(ctx, parameter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) *card.ListCardViewModel); ok {
		r0 = rf(ctx, parameter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*card.ListCardViewModel)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, queryParameter.QueryParameter) error); ok {
		r1 = rf(ctx, parameter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_ListCard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCard'
type Storage_ListCard_Call struct {
	*mock.Call
}

// ListCard is a helper method to define mock.On call
//   - ctx context.Context
//   - parameter queryParameter.QueryParameter
func (_e *Storage_Expecter) ListCard(ctx interface{}, parameter interface{}) *Storage_ListCard_Call {
	return &Storage_ListCard_Call{Call: _e.mock.On("ListCard", ctx, parameter)}
}

func (_c *Storage_ListCard_Call) Run(run func(ctx context.Context, parameter queryParameter.QueryParameter)) *Storage_ListCard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(queryParameter.QueryParameter))
	})
	return _c
}

func (_c *Storage_ListCard_Call) Return(_a0 *card.ListCardViewModel, _a1 error) *Storage_ListCard_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_ListCard_Call) RunAndReturn(run func(context.Context, queryParameter.QueryParameter) (*card.ListCardViewModel, error)) *Storage_ListCard_Call {
	_c.Call.Return(run)
	return _c
}

// ListText provides a mock function with given fields: ctx, parameter
func (_m *Storage) ListText(ctx context.Context, parameter queryParameter.QueryParameter) (*text.ListTextViewModel, error) {
	ret := _m.Called(ctx, parameter)

	var r0 *text.ListTextViewModel
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) (*text.ListTextViewModel, error)); ok {
		return rf(ctx, parameter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, queryParameter.QueryParameter) *text.ListTextViewModel); ok {
		r0 = rf(ctx, parameter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*text.ListTextViewModel)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, queryParameter.QueryParameter) error); ok {
		r1 = rf(ctx, parameter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_ListText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListText'
type Storage_ListText_Call struct {
	*mock.Call
}

// ListText is a helper method to define mock.On call
//   - ctx context.Context
//   - parameter queryParameter.QueryParameter
func (_e *Storage_Expecter) ListText(ctx interface{}, parameter interface{}) *Storage_ListText_Call {
	return &Storage_ListText_Call{Call: _e.mock.On("ListText", ctx, parameter)}
}

func (_c *Storage_ListText_Call) Run(run func(ctx context.Context, parameter queryParameter.QueryParameter)) *Storage_ListText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(queryParameter.QueryParameter))
	})
	return _c
}

func (_c *Storage_ListText_Call) Return(_a0 *text.ListTextViewModel, _a1 error) *Storage_ListText_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_ListText_Call) RunAndReturn(run func(context.Context, queryParameter.QueryParameter) (*text.ListTextViewModel, error)) *Storage_ListText_Call {
	_c.Call.Return(run)
	return _c
}

// LoginUser provides a mock function with given fields: ctx, _a1, _a2
func (_m *Storage) LoginUser(ctx context.Context, _a1 email.Email, _a2 password.Password) (*user.User, error) {
	ret := _m.Called(ctx, _a1, _a2)

	var r0 *user.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, email.Email, password.Password) (*user.User, error)); ok {
		return rf(ctx, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, email.Email, password.Password) *user.User); ok {
		r0 = rf(ctx, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, email.Email, password.Password) error); ok {
		r1 = rf(ctx, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_LoginUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoginUser'
type Storage_LoginUser_Call struct {
	*mock.Call
}

// LoginUser is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 email.Email
//   - _a2 password.Password
func (_e *Storage_Expecter) LoginUser(ctx interface{}, _a1 interface{}, _a2 interface{}) *Storage_LoginUser_Call {
	return &Storage_LoginUser_Call{Call: _e.mock.On("LoginUser", ctx, _a1, _a2)}
}

func (_c *Storage_LoginUser_Call) Run(run func(ctx context.Context, _a1 email.Email, _a2 password.Password)) *Storage_LoginUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(email.Email), args[2].(password.Password))
	})
	return _c
}

func (_c *Storage_LoginUser_Call) Return(_a0 *user.User, _a1 error) *Storage_LoginUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_LoginUser_Call) RunAndReturn(run func(context.Context, email.Email, password.Password) (*user.User, error)) *Storage_LoginUser_Call {
	_c.Call.Return(run)
	return _c
}

// SetTokenUser provides a mock function with given fields: ctx, _a1
func (_m *Storage) SetTokenUser(ctx context.Context, _a1 *user.User) bool {
	ret := _m.Called(ctx, _a1)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, *user.User) bool); ok {
		r0 = rf(ctx, _a1)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Storage_SetTokenUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTokenUser'
type Storage_SetTokenUser_Call struct {
	*mock.Call
}

// SetTokenUser is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *user.User
func (_e *Storage_Expecter) SetTokenUser(ctx interface{}, _a1 interface{}) *Storage_SetTokenUser_Call {
	return &Storage_SetTokenUser_Call{Call: _e.mock.On("SetTokenUser", ctx, _a1)}
}

func (_c *Storage_SetTokenUser_Call) Run(run func(ctx context.Context, _a1 *user.User)) *Storage_SetTokenUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*user.User))
	})
	return _c
}

func (_c *Storage_SetTokenUser_Call) Return(_a0 bool) *Storage_SetTokenUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_SetTokenUser_Call) RunAndReturn(run func(context.Context, *user.User) bool) *Storage_SetTokenUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAccount provides a mock function with given fields: ctx, _a1
func (_m *Storage) UpdateAccount(ctx context.Context, _a1 *account.Account) (*account.Account, error) {
	ret := _m.Called(ctx, _a1)

	var r0 *account.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *account.Account) (*account.Account, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *account.Account) *account.Account); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *account.Account) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_UpdateAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAccount'
type Storage_UpdateAccount_Call struct {
	*mock.Call
}

// UpdateAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *account.Account
func (_e *Storage_Expecter) UpdateAccount(ctx interface{}, _a1 interface{}) *Storage_UpdateAccount_Call {
	return &Storage_UpdateAccount_Call{Call: _e.mock.On("UpdateAccount", ctx, _a1)}
}

func (_c *Storage_UpdateAccount_Call) Run(run func(ctx context.Context, _a1 *account.Account)) *Storage_UpdateAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*account.Account))
	})
	return _c
}

func (_c *Storage_UpdateAccount_Call) Return(_a0 *account.Account, _a1 error) *Storage_UpdateAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_UpdateAccount_Call) RunAndReturn(run func(context.Context, *account.Account) (*account.Account, error)) *Storage_UpdateAccount_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBinary provides a mock function with given fields: ctx, _a1
func (_m *Storage) UpdateBinary(ctx context.Context, _a1 *binary.BinaryData) (*binary.BinaryData, error) {
	ret := _m.Called(ctx, _a1)

	var r0 *binary.BinaryData
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *binary.BinaryData) (*binary.BinaryData, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *binary.BinaryData) *binary.BinaryData); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*binary.BinaryData)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *binary.BinaryData) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_UpdateBinary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBinary'
type Storage_UpdateBinary_Call struct {
	*mock.Call
}

// UpdateBinary is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *binary.BinaryData
func (_e *Storage_Expecter) UpdateBinary(ctx interface{}, _a1 interface{}) *Storage_UpdateBinary_Call {
	return &Storage_UpdateBinary_Call{Call: _e.mock.On("UpdateBinary", ctx, _a1)}
}

func (_c *Storage_UpdateBinary_Call) Run(run func(ctx context.Context, _a1 *binary.BinaryData)) *Storage_UpdateBinary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*binary.BinaryData))
	})
	return _c
}

func (_c *Storage_UpdateBinary_Call) Return(_a0 *binary.BinaryData, _a1 error) *Storage_UpdateBinary_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_UpdateBinary_Call) RunAndReturn(run func(context.Context, *binary.BinaryData) (*binary.BinaryData, error)) *Storage_UpdateBinary_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCard provides a mock function with given fields: ctx, _a1
func (_m *Storage) UpdateCard(ctx context.Context, _a1 *card.CardData) (*card.CardData, error) {
	ret := _m.Called(ctx, _a1)

	var r0 *card.CardData
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *card.CardData) (*card.CardData, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *card.CardData) *card.CardData); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*card.CardData)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *card.CardData) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_UpdateCard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCard'
type Storage_UpdateCard_Call struct {
	*mock.Call
}

// UpdateCard is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *card.CardData
func (_e *Storage_Expecter) UpdateCard(ctx interface{}, _a1 interface{}) *Storage_UpdateCard_Call {
	return &Storage_UpdateCard_Call{Call: _e.mock.On("UpdateCard", ctx, _a1)}
}

func (_c *Storage_UpdateCard_Call) Run(run func(ctx context.Context, _a1 *card.CardData)) *Storage_UpdateCard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*card.CardData))
	})
	return _c
}

func (_c *Storage_UpdateCard_Call) Return(_a0 *card.CardData, _a1 error) *Storage_UpdateCard_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_UpdateCard_Call) RunAndReturn(run func(context.Context, *card.CardData) (*card.CardData, error)) *Storage_UpdateCard_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateText provides a mock function with given fields: ctx, _a1
func (_m *Storage) UpdateText(ctx context.Context, _a1 *text.TextData) (*text.TextData, error) {
	ret := _m.Called(ctx, _a1)

	var r0 *text.TextData
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *text.TextData) (*text.TextData, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *text.TextData) *text.TextData); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*text.TextData)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *text.TextData) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_UpdateText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateText'
type Storage_UpdateText_Call struct {
	*mock.Call
}

// UpdateText is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *text.TextData
func (_e *Storage_Expecter) UpdateText(ctx interface{}, _a1 interface{}) *Storage_UpdateText_Call {
	return &Storage_UpdateText_Call{Call: _e.mock.On("UpdateText", ctx, _a1)}
}

func (_c *Storage_UpdateText_Call) Run(run func(ctx context.Context, _a1 *text.TextData)) *Storage_UpdateText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*text.TextData))
	})
	return _c
}

func (_c *Storage_UpdateText_Call) Return(_a0 *text.TextData, _a1 error) *Storage_UpdateText_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_UpdateText_Call) RunAndReturn(run func(context.Context, *text.TextData) (*text.TextData, error)) *Storage_UpdateText_Call {
	_c.Call.Return(run)
	return _c
}

// NewStorage creates a new instance of Storage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *Storage {
	mock := &Storage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
